<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rules>
  <rule key="UnnecessaryAbstraction">
  	<severity>MAJOR</severity>
    <name><![CDATA[Unnecessary Abstraction]]></name>
    <description><![CDATA[This smell occurs when an abstraction which is actually not needed (and thus could have been avoided) gets introduced in a software design.]]></description>
  	<tag>design</tag>
  </rule>
  <rule key="ImperativeAbstraction">
  <severity>CRITICAL</severity>
    <name><![CDATA[Imperative Abstraction]]></name>
    <description><![CDATA[This smell arises when an operation is turned into a class.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="MultifacetedAbstraction">
  <severity>CRITICAL</severity>
    <name><![CDATA[Multifaceted Abstraction]]></name>
    <description><![CDATA[This smell arises when an abstraction has more than one responsibility assigned to it.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="UnutilizedAbstraction">
  <severity>MAJOR</severity>
    <name><![CDATA[Unutilized Abstraction]]></name>
    <description><![CDATA[This smell arises when an abstraction is left unused (either not directly used or not reachable).]]></description>
    <tag>design</tag>
  </rule>
  <rule key="DuplicateAbstraction">
  <severity>CRITICAL</severity>
    <name><![CDATA[Duplicate Abstraction]]></name>
    <description><![CDATA[This smell arises when two or more abstractions have identical names or identical implementation or both.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="DeficientEncapsulation">
  <severity>MAJOR</severity>
    <name><![CDATA[Deficient Encapsulation]]></name>
    <description><![CDATA[This smell occurs when the declared accessibility of one or more members of an abstraction is more permissive than actually required.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="UnexloitedEncapsulation">
  <severity>CRITICAL</severity>
    <name><![CDATA[Unexloited Encapsulation]]></name>
    <description><![CDATA[This smell arises when client code uses explicit type checks (using chained if-else or switch statements that check for the type of the object) instead of exploiting the variation in types already encapsulated within a hierarchy.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="BrokenModularization">
  <severity>MAJOR</severity>
    <name><![CDATA[Broken Modularization]]></name>
    <description><![CDATA[This smell arises when data and/or methods that ideally should have been localized into a single abstraction are separated and spread across multiple abstractions.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="InsufficientModularization">
  <severity>CRITICAL</severity>
    <name><![CDATA[Insufficient Modularization]]></name>
    <description><![CDATA[This smell arises when an abstraction exists that has not been completely decomposed and a further decomposition could reduce its size, implementation complexity, or both.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="Hub-likeModularization">
  <severity>CRITICAL</severity>
    <name><![CDATA[Hub-like Modularization]]></name>
    <description><![CDATA[This smell arises when an abstraction has dependencies (both incoming and outgoing) with a large number of other abstractions.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="Cyclically-dependentModularization" >
  <severity>CRITICAL</severity>
    <name><![CDATA[Cyclically-dependent Modularization]]></name>
    <description><![CDATA[This smell arises when two or more abstractions depend on each other directly or indirectly (creating a tight coupling between the abstractions).]]></description>
    <tag>design</tag>
  </rule>
  <rule key="WideHierarchy">
  <severity>MAJOR</severity>
    <name><![CDATA[Wide Hierarchy]]></name>
    <description><![CDATA[This smell arises when an inheritance hierarchy is "too" wide indicating that intermediate abstractions may be missing.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="DeepHierarchy">
  <severity>MAJOR</severity>
    <name><![CDATA[Deep Hierarchy]]></name>
    <description><![CDATA[This smell arises when an inheritance hierarchy is "excessively" deep.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="MultipathHierarchy">
  <severity>MINOR</severity>
    <name><![CDATA[Multipath Hierarchy]]></name>
    <description><![CDATA[This smell arises when a subtype inherits both directly as well as indirectly from a supertype leading to unnecessary inheritance paths in the hierarchy.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="CyclicHierarchy">
  <severity>CRITICAL</severity>
    <name><![CDATA[Cyclic Hierarchy]]></name>
    <description><![CDATA[This smell arises when a supertype in a hierarchy depends on any of its subtypes.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="RebelliousHierarchy">
  <severity>MAJOR</severity>
    <name><![CDATA[Rebellious Hierarchy]]></name>
    <description><![CDATA[This smell arises when a subtype rejects the methods provided by its supertype(s).]]></description>
    <tag>design</tag>
  </rule>
  <rule key="MissingHierarchy">
  <severity>CRITICAL</severity>
    <name><![CDATA[Missing Hierarchy]]></name>
    <description><![CDATA[This smell arises when a code segment uses conditional logic (typically in conjunction with “tagged types”) to explicitly manage variation in behavior where a hierarchy could have been created and used to encapsulate those variations.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="UnfactoredHierarchy">
  <severity>CRITICAL</severity>
    <name><![CDATA[Unfactored Hierarchy]]></name>
    <description><![CDATA[This smell arises when there is unnecessary duplication among types in a hierarchy.]]></description>
    <tag>design</tag>
  </rule>
  <rule key="BrokenHierarchy">
  <severity>MAJOR</severity>
  <name><![CDATA[Broken Hierarchy]]></name>
  <description><![CDATA[This smell arises when a supertype and its subtype conceptually do not share an "IS-A" relationship resulting in broken substitutability.]]></description>
  <tag>design</tag>
  </rule>
  <rule key="LongMethod">
  <severity>MAJOR</severity>
  <name><![CDATA[Long Method]]></name>
  <description><![CDATA[The smell arises when a method is long.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="ComplexMethod">
  <severity>MAJOR</severity>
  <name><![CDATA[Complex Method]]></name>
  <description><![CDATA[The smell arises when a method is complex (in terms of cyclomatic complexity).]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="LongParameterList">
  <severity>MAJOR</severity>  
  <name><![CDATA[Long Parameter List]]></name>
  <description><![CDATA[The smell arises when a method has a long list of parameters.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="LongIdentifier">
  <severity>MINOR</severity>
  <name><![CDATA[Long Identifier]]></name>
  <description><![CDATA[The smell arises when an identifier is long.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="LongStatement">
  <severity>MINOR</severity>
  <name><![CDATA[Long Statement]]></name>
  <description><![CDATA[The smell arises when a statement is long.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="ComplexConditional">
  <severity>MINOR</severity>
  <name><![CDATA[Complex Conditional]]></name>
  <description><![CDATA[The smell arises when a conditional expression is complex.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="VirtualMethodCallfromConstructor">
  <severity>MAJOR</severity>
  <name><![CDATA[Virtual Method Call from Constructor]]></name>
  <description><![CDATA[The smell arises when a constructor calls a virtual method.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="EmptyCatchBlock">
  <severity>MINOR</severity>
  <name><![CDATA[Empty Catch Block]]></name>
  <description><![CDATA[The smell arises when a catch block is empty.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="MagicNumber">
  <severity>MINOR</severity>
  <name><![CDATA[Magic Number]]></name>
  <description><![CDATA[The smell arises when a potentially unexplained literal is used in an expression.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="DuplicateCode">
  <severity>MAJOR</severity>
  <name><![CDATA[Duplicate Code]]></name>
  <description><![CDATA[The smell arises when a method has a code clone-set.]]></description>
  <tag>bad-practice</tag>
  </rule>
  <rule key="MissingDefault">
  <severity>MINOR</severity>
  <name><![CDATA[Missing Default]]></name>
  <description><![CDATA[The smell arises when a switch statement does not contain a default case.]]></description>
  <tag>bad-practice</tag>
  </rule>
</rules>
